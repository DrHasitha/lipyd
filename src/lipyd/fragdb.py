#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
#  This file is part of the `lipyd` python module
#
#  Copyright (c) 2015-2018 - EMBL
#
#  File author(s): Dénes Türei (turei.denes@gmail.com)
#
#  This code is not for public use.
#  Please do not redistribute.
#  For permission please contact me.
#
#  Website: http://www.ebi.ac.uk/~denes
#

from __future__ import print_function
from future.utils import iteritems
from past.builtins import xrange, range, reduce

import itertools
import collections
import copy
import numpy as np

import lipyd.fragment as fragment
import lipyd.formula as formula
import lipyd.settings as settings
import lipyd.lookup as lookup


class FragmentDatabaseAggregator(object):
    
    default_args = {
        'sphingo': 'sph_default',
        'fa': 'fa_default',
        'fal': 'fal_default'
    }
    
    def __init__(
            self,
            ionmode = 'pos',
            tolerance = 50,
            files = None,
            include = None,
            exclude = None,
            fa_default  = None,
            sph_default = None,
            fal_default = None,
            build = True
        ):
        """
        Builds and serves a database of MS2 fragment ions according to
        certain criteria.
        
        Fragments data can be either read from built in or user provided
        files, or homolog series of alkyl chain containing fragments
        can be generated by classes provided in the `fragment` module.
        You can select which of these homolog series should be generated
        and by which parameters. By default fragments from the built in
        list are read to avoid this provide a value for `files` argument.
        This might be an empty list or a list of files with your custom
        fragments, or a single filename string.
        
        Args
        ----
        :param str ionmode:
            Ion mode, either `pos` or `neg`.
        :param int tolerance:
            Tolerance at lookup in ppm.
        :param str,list files:
            Fragment list filenames. List of filenames or a single
            filename. If `None` the built in fragment list file used.
        :param list include:
            List of homolog series classes. Names of class defined in
            the `fragment` module, optionally tuples of class names
            and dict of arguments.
        :param list exclude:
            List of class names not to be used to generate fragment
            series.
        :param dict fa_default:
            Default arguments for fatty acyl derived fragment series.
        :param dict fa_default:
            Default arguments for fatty alkyl derived fragment series.
        :param dict sph_default:
            Default arguements for sphingoid long chain base derived
            fragment series.
        :param bool build:
            Build the fragment database at initialization.
        """
        
        self.fragments = []
        self.mode  = ionmode
        self.tolerance = tolerance
        self.files = files
        self.include = include
        self.exclude = exclude or []
        self.fa_default  = fa_default  or {
            'c': range(2, 37),
            'u': range(0, 7)
        }
        self.fal_default = fal_default or self.fa_default
        self.sph_default = sph_default or {
            'c': [14, 16, 17, 18, 19, 20, 21],
            'u': (0, 1)
        }
        
        if build:
            
            self.build()
    
    def build(self):
        """
        Builds the fragment list.
        
        Reads files and auto-generates programmatically calculated
        homolog series.
        """
        
        self.fragments = []
        
        self.set_filenames()
        self.fragments = self.read_files()
        self.fragments.extend(self.generate_series())
        self.fragments = np.array(
            sorted(
                self.fragments,
                key = lambda x: x[0]
            ),
            dtype = np.object
        )
    
    def __iter__(self):
        
        return self.fragments.__iter__()
    
    def set_filenames(self):
        """
        Sets the `files` attribute to be a list of filenames.
        If no `files` argument provided the built in default
        fragment list files will be used.
        """
        
        self.files = (
                [self.files]
            if hasattr(self.files, 'lower') else
                [self.get_default_file()]
            if self.files is None else
                self.files
        )
    
    def get_default_file(self):
        """
        Returns the file name of the default fragment lists.
        
        These are stored in the `pfragmentsfile` and `nfragmentsfile`
        settings for positive and negative ion modes, respectively.
        The fragment list files should have at least 4 columns:
            * m/z as float
            * formula -- either formula or m/z should be provided,
              mass calculation from formula has priority over the
              mass in first column
            * human readable name
            * type: e.g. `[M+H]+`; importantly, for neutral losses
              this value must start with `NL`
            * headgroups (lipid classes), e.g.`PC;SM`
        
        See the built in fragment lists for examples.
        """
        
        return settings.get('%sfragmentsfile' % (
            'p' if self.mode == 'pos' else 'n'
        ))
    
    def read_files(self):
        """
        Returns the list of fragments read from all files.
        """
        
        return (
            list(
                itertools.chain(
                    *(self.read_file(fname) for fname in self.files)
                )
            )
        )
    
    def read_file(self, fname = None):
        """
        Reads a list of MS2 fragments from a file.
        Returns list of fragments.
        
        If no filename provided the default fragment lists will be read.
        The fragment list files should have at least 4 columns:
            * m/z as float
            * formula -- either formula or m/z should be provided,
              mass calculation from formula has priority over the
              mass in first column
            * human readable name
            * type: e.g. `[M+H]+`; importantly, for neutral losses
              this value must start with `NL`
            * headgroups (lipid classes), e.g.`PC;SM`
        
        See the built in fragment lists for examples.
        """
        
        def get_charge(typ):
            
            return (
                0  if typ.startswith('NL') else
                -1 if self.mode == 'neg' else
                1
            )
        
        def process_line(l):
            
            l = l.split('\t')
            
            mass = (
                    formula.Formula(l[1]).mass
                if l[1] else
                    float(l[0])
                if l[0] else
                    None
            )
            
            return [mass, l[2], l[3], np.nan, np.nan, get_charge(l[3])]
        
        fname = fname or self.get_default_file()
        
        with open(fname, 'r') as fp:
            
            return [
                ll for ll in
                    (
                        process_line(l) for l in
                        filter(bool, fp.read().split('\n'))
                    )
                if ll and ll[0]
            ]
    
    def set_series(self):
        """
        Selects the homolog series to be generated and their parameters.
        See details in docs of `exclude` and `include` arguments for
        `__init__()`.
        """
        
        def get_class(name):
            
            # TODO be able to use classes defined elsewhere
            return getattr(fragment, name)
        
        self.specific_args = collections.defaultdict(dict)
        
        if self.include is not None:
            
            # a set of fragment class names
            self.series = set(
                i[0] if type(i) is tuple else i for i in self.include
            )
            # a dict with class specific arguments
            # whereever it's provided
            self.specific_args.update(
                dict(filter(lambda x: type(x) is tuple, self.include))
            )
            
        else:
            
            # all fragment classes by default except those in `exclude`
            self.series = fragment.fattyfragments - set(self.exclude)
        
        self.series = map(get_class, self.series)
        self.series = [cls for cls in self.series if cls.mode == self.mode]
    
    def get_series_args(self, cls):
        """
        Provides a dict of arguments for fragment homolog series.
        
        Args
        ----
        :param class cls:
            Fragment homolog series class
            e.g. `fragment.FA_mH` -- fatty acid minus hydrogen.
        """
        
        args = (
                copy.copy(getattr(self, self.default_args[cls.typ]))
            if cls.typ in self.default_args else
                {}
        )
        
        args.update(self.specific_args[cls])
        
        return args
    
    def generate_series(self):
        """
        Generates homolog series fragments.
        """
        
        result = []
        
        self.set_series()
        
        for cls in self.series:
            
            args = self.get_series_args(cls)
            
            result.extend(list(cls(**args).iterfraglines()))
        
        return result
    
    def __getitem__(self, i):
        
        return self.fragments[i,:]
    
    def lookup(self, mz):
        """
        Searches for fragments in the database matching the `mz` within the
        actual range of tolerance. To change the tolerance set the
        `tolerance` attribute to the desired ppm value.
        """
        
        return self.fragments[
            lookup.findall(self.fragments[:,0], mz, self.tolerance),
            :
        ]
